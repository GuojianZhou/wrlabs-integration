#
# Copyright (C) 2015-2016 Wind River Systems, Inc.
#

require efitools.inc

SRC_URI_append = " \
    file://LockDown-enable-the-enrollment-for-DBX.patch \
"

COMPATIBLE_HOST = '(i.86|x86_64).*-linux'

inherit user-key-store

# The generated native binaries are used during native and target build
DEPENDS_append = " ${BPN}-native gnu-efi openssl"

RDEPENDS_${PN}_append = " \
    parted mtools coreutils util-linux openssl \
"

EXTRA_OEMAKE_append = " \
    INCDIR_PREFIX='${STAGING_DIR_TARGET}' \
    CRTPATH_PREFIX='${STAGING_DIR_TARGET}' \
    SIGN_EFI_SIG_LIST='${STAGING_BINDIR_NATIVE}/sign-efi-sig-list' \
    CERT_TO_EFI_SIG_LIST='${STAGING_BINDIR_NATIVE}/cert-to-efi-sig-list' \
    CERT_TO_EFI_HASH_LIST='${STAGING_BINDIR_NATIVE}/cert-to-efi-hash-list' \
    HASH_TO_EFI_SIG_LIST='${STAGING_BINDIR_NATIVE}/hash-to-efi-sig-list' \
    MYGUID='${UEFI_SIG_OWNER_GUID}' \
"

python do_prepare_signing_keys() {
    if '${UEFI_SB}' != '1':
        return

    import shutil

    dir = uefi_sb_keys_dir(d)

    # Prepare PK, KEK and DB for LockDown.efi.
    for _ in ('PK', 'KEK', 'DB'):
        shutil.copyfile(dir + _ + '.pem', '${S}/' + _ + '.crt')
        shutil.copyfile(dir + _ + '.key', '${S}/' + _ + '.key')

    create_uefi_dbx(d)
}
addtask prepare_signing_keys after do_configure before do_compile

# DBX.esl will be generated by this rule: 
# %.esl: %.crt cert-to-efi-sig-list
#        $(CERT_TO_EFI_SIG_LIST) -g $(MYGUID) $< $@
#
# However, this DBX.esl embedded in LockDown.efi doesn't have the
# expected contents. We have to rebuild LockDown.efi.
do_compile_append() {
    if [ x"${UEFI_SB}" != x"1" -o x"${USE_USER_KEY}" != x"1" ]; then
        return
    fi
    
    cp -f "${TMPDIR}/blacklist.esl" DBX.esl
    rm -f LockDown.efi LockDown.so LockDown.o DBX.h DBX.auth
    oe_runmake LockDown.efi
}

do_install_append() {
    install -d ${D}${EFI_BOOT_PATH}
    install -m 0755 ${D}${datadir}/efitools/efi/LockDown.efi ${D}${EFI_BOOT_PATH}
}
